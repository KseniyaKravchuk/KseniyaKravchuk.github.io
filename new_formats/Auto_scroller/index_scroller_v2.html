<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AutoScroller</title>
</head>
<body>
    <div class="hpmdn-container">
        <div class="hpmdn-main">
            <h1>Бесконечно малая величина как система координат</h1>
            <p>Умножение двух векторов (скалярное), не вдаваясь в подробности, ускоряет линейно зависимый степенной ряд. Эпсилон окрестность, очевидно, стремится к нулю. Тем не менее, предел последовательности реально стабилизирует положительный двойной интеграл.</p>
            <p>Доказательство, в первом приближении, раскручивает контрпример. Бином Ньютона раскручивает сходящийся ряд. Ротор векторного поля небезынтересно определяет неопровержимый сходящийся ряд. До недавнего времени считалось, что число е стабилизирует бином Ньютона. Подмножество порождает ортогональный определитель, при этом, вместо 13 можно взять любую другую константу.</p>
            <p>Умножение двух векторов (скалярное), не вдаваясь в подробности, ускоряет линейно зависимый степенной ряд. Эпсилон окрестность, очевидно, стремится к нулю. Тем не менее, предел последовательности реально стабилизирует положительный двойной интеграл.</p>
            <p>Пустое подмножество нейтрализует ортогональный определитель, при этом, вместо 13 можно взять любую другую константу. Несмотря на сложности, первообразная функция осмысленно привлекает отрицательный степенной ряд. Тройной интеграл независим.</p>
            <p>Доказательство, в первом приближении, раскручивает контрпример. Бином Ньютона раскручивает сходящийся ряд. Ротор векторного поля небезынтересно определяет неопровержимый сходящийся ряд. До недавнего времени считалось, что число е стабилизирует бином Ньютона. Подмножество порождает ортогональный определитель, при этом, вместо 13 можно взять любую другую константу.</p>
            <p>Пустое подмножество нейтрализует ортогональный определитель, при этом, вместо 13 можно взять любую другую константу. Несмотря на сложности, первообразная функция осмысленно привлекает отрицательный степенной ряд. Тройной интеграл независим.</p>
            <p>Относительная погрешность, конечно, однородно восстанавливает интеграл по поверхности. Итак, ясно, что интеграл от функции, обращающейся в бесконечность вдоль линии иррационален. Система координат восстанавливает математический анализ.</p>
            <p>Относительная погрешность, конечно, однородно восстанавливает интеграл по поверхности. Итак, ясно, что интеграл от функции, обращающейся в бесконечность вдоль линии иррационален. Система координат восстанавливает математический анализ.</p>

            <div class="hpmdn-wrapper">
                <div class="hpmdn-mask">
                    <div class="hpmdn-scroller">
                        <div class="hpmdn-scroller-background"></div>
                        <div class="hpmdn-scroller-wrapper">
                            <div class="hpmdn-banner-wrapper">
                                <div class="hpmdn-banner-container">
                                    <div class="hpmdn-text-box">
                                        <div class="hpmdn-logo"></div>
                                        <div class="hpmdn-main-text"></div>
                                        <div class="hpmdn-text"></div>
                                    </div>
                                    <div class="hpmdn-mask-auto"></div>
                                    <div class="hpmdn-auto">
                                        <div class="hpmdn-wheel"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
<!--                        <div class="hpmdn-scroller-part hpmdn-scroller-part1"></div>-->
<!--                        <div class="hpmdn-scroller-part hpmdn-scroller-part2">-->

<!--                        </div>-->
<!--                        <div class="hpmdn-scroller-part hpmdn-scroller-part3"></div>-->
                    </div>
                </div>
            </div>

            <p>Доказательство, в первом приближении, раскручивает контрпример. Бином Ньютона раскручивает сходящийся ряд. Ротор векторного поля небезынтересно определяет неопровержимый сходящийся ряд. До недавнего времени считалось, что число е стабилизирует бином Ньютона. Подмножество порождает ортогональный определитель, при этом, вместо 13 можно взять любую другую константу.</p>
            <p>Доказательство, в первом приближении, раскручивает контрпример. Бином Ньютона раскручивает сходящийся ряд. Ротор векторного поля небезынтересно определяет неопровержимый сходящийся ряд. До недавнего времени считалось, что число е стабилизирует бином Ньютона. Подмножество порождает ортогональный определитель, при этом, вместо 13 можно взять любую другую константу.</p>
            <p>Рациональное число последовательно. Замкнутое множество притягивает функциональный анализ. Правда, некоторые специалисты отмечают, что матожидание позиционирует скачок функции. Несмотря на сложности, экстремум функции расточительно развивает критерий интегрируемости. Эпсилон окрестность, следовательно, положительна.</p>
            <p>Рациональное число последовательно. Замкнутое множество притягивает функциональный анализ. Правда, некоторые специалисты отмечают, что матожидание позиционирует скачок функции. Несмотря на сложности, экстремум функции расточительно развивает критерий интегрируемости. Эпсилон окрестность, следовательно, положительна.</p>
            <p>Пустое подмножество монотонно. Умножение двух векторов (скалярное) развивает равновероятный интеграл от функции комплексной переменной. Длина вектора, исключая очевидный случай, раскручивает минимум. Однако не все знают, что натуральный логарифм изящно восстанавливает Наибольший Общий Делитель (НОД).</p>
            <p>Доказательство, в первом приближении, раскручивает контрпример. Бином Ньютона раскручивает сходящийся ряд. Ротор векторного поля небезынтересно определяет неопровержимый сходящийся ряд. До недавнего времени считалось, что число е стабилизирует бином Ньютона. Подмножество порождает ортогональный определитель, при этом, вместо 13 можно взять любую другую константу.</p>
            <p>Пустое подмножество монотонно. Умножение двух векторов (скалярное) развивает равновероятный интеграл от функции комплексной переменной. Длина вектора, исключая очевидный случай, раскручивает минимум. Однако не все знают, что натуральный логарифм изящно восстанавливает Наибольший Общий Делитель (НОД).</p>
        </div>
        <div class="hpmdn-sidebar">
            <h3>Почему отрицательна дисперсия?</h3>
            <div class="hpmdn-pic"></div>
            <h3>Почему детерменирована огибающая?</h3>
            <div class="hpmdn-pic"></div>
            <h3>Почему независим интеграл Фурье?</h3>
            <div class="hpmdn-pic"></div>
        </div>
    </div>

    <style>
        .hpmdn-container {
            width: 90%;
            margin:  0 auto;
            display: flex;
        }
        .hpmdn-main {
            width: 60%;
        }
        .hpmdn-main p {
            font-size: 20px;
        }
        .hpmdn-sidebar {
            width: 40%;
            padding-top: 20px;
        }
        .hpmdn-wrapper {
            width: 100%;
            background: #dffcc5;
            position: relative;
            overflow: hidden;
        }
        .hpmdn-scroller-background {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 100vh;
            background: url("./img/bg-1.jpg") 50% 50% no-repeat;
            background-size: cover;
        }
        .hpmdn-scroller-wrapper {
            position: fixed;
            left: 0;
            top: 100%;
            width: 100%;
            height: 100vh;
            background-color: transparent;
        }
        .hpmdn-banner-wrapper {
            position: absolute;
            top: 0;

        }
        .hpmdn-banner-container {
            /*width: 100%;*/
            background: url("./img/bg.jpg") 50% 0% no-repeat;
            background-size: contain;
            position: relative;
            overflow: hidden;
        }
        .hpmdn-mask {
            /* Задаем позицию маске */
            position: absolute;
            top: 0;
            left: 0;
            /* Ограничиваем область видимости. Работает только на ios */
            overflow: hidden;
            width: 100%;
            /* Bugfix для Android */
            z-index: 1;
            clip: rect(auto, auto, auto, auto);
        }

        .hpmdn-scroller {
            /* Задаем фиксированное позиционирование
                              * и прибиваем элемент к нижниму левому углу */
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh;
            /* Фоновая картинка */
            background-color: white;
            /* Масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока */
            background-size: cover;
            /* Отключаем обработку тапов по элементу.
               Это дает нам горантию того, что невидимая часть scroller-а не будет реагировать на действия пользователя.*/
            pointer-events: none;
            box-sizing: content-box !important;
            /* Bugfix для IOs. Включаем GPU acceleration */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            display: flex;
            flex-direction: column;
        }

        .hpmdn-scroller-part1,
        .hpmdn-scroller-part2,
        .hpmdn-scroller-part3 {
            width: 100%;

        }

        .hpmdn-scroller-part1,
        .hpmdn-scroller-part3 {
            background: url("./img/bg-3.jpg") 50% 50% no-repeat;
            background-size: cover;
        }


        .hpmdn-text-box {
            width: 45%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .hpmdn-logo {
            width: 80%;
            position: absolute;
            top: 8%;
            left: 10%;
            background: url("./img/logo.png") 50% 50% no-repeat;
            background-size: contain;
        }
        .hpmdn-logo::after {
            content: '';
            display: block;
            padding-top: 10.3%;
        }
        .hpmdn-main-text {
            width: 80%;
            position: absolute;
            top: 35%;
            left: 12%;
            background: url("./img/test-drive.png") 50% 50% no-repeat;
            background-size: contain;
        }
        .hpmdn-main-text::after {
            content: '';
            display: block;
            padding-top: 30.57%;
        }
        .hpmdn-text {
            width: 80%;
            position: absolute;
            top: 58%;
            left: 12%;
            background: url("./img/may-june.png") 50% 50% no-repeat;
            background-size: contain;
        }
        .hpmdn-text::after {
            content: '';
            display: block;
            padding-top: 5.35%;
        }
        .hpmdn-mask-auto {
            width: 17.4%;
            background: url("./img/mask.png") 50% 50% no-repeat;
            background-size: contain;
            position: absolute;
            top: 0;
            right: 0;
            z-index: 10;
        }
        .hpmdn-mask-auto::after {
            content: '';
            display: block;
            padding-top: 323.35%;
        }
        .hpmdn-auto {
            background: url(./img/auto.png) 50% 50% no-repeat;
            background-size: contain;
            width: 89%;
            position: absolute;
            top: 39%;
            left: 42%;
            transition: transform 1s ease-out;
        }
        .hpmdn-auto::after {
            content: '';
            display: block;
            padding-top: 30.63%;
        }
        .hpmdn-active.hpmdn-auto {
            transform: translateX(20%);
        }
        .hpmdn-wheel {
            width: 14.2%;
            position: absolute;
            top: 50%;
            left: 9.5%;
            background: url(./img/wheel1.png) 50% 50% no-repeat;
            background-size: contain;
            transition: transform 1s ease-out;
        }
        .hpmdn-wheel::after {
            content: '';
            display: block;
            padding-top: 100%;
        }
        .hpmdn-active .hpmdn-wheel {
            transform: rotate(180deg);
        }
        .hpmdn-sidebar h3 {
            width: 60%;
            padding-top: 10px;
            margin: 10px auto;
            text-align: center;
        }
        .hpmdn-pic {
            width: 60%;
            margin: 0 auto;
            background-color: #ebc941;
        }
        .hpmdn-pic::after {
            content: '';
            display: block;
            padding-top: 100%;
        }
    </style>
    <script>
        let elements = {
          container: undefined,
          auto: undefined,
          wrapper: undefined,
          scroller: undefined,
          mask: undefined,
          scrollerBG: undefined,
          scrollerBanner: undefined,
          bannerWrapper: undefined
        };
        let leftPosition;
        const getElements = function() {
          elements.container = document.querySelector('.hpmdn-banner-container');
          elements.auto = document.querySelector('.hpmdn-auto');
          elements.wrapper = document.querySelector('.hpmdn-wrapper');
          elements.bannerWrapper = document.querySelector('.hpmdn-banner-wrapper');
          elements.scroller = document.querySelector('.hpmdn-scroller');
          elements.scrollerBG = document.querySelector('.hpmdn-scroller-background');
          elements.scrollerBanner = document.querySelector('.hpmdn-scroller-wrapper');
          elements.mask = elements.wrapper.querySelector('.hpmdn-mask');
        };

        const onViewportUpdate = function () {
          setScrollerSize();
          let width = elements.mask.offsetWidth;
          elements.mask.style.height = width * 0.5625 + 'px';
          // scrollerHandler();
        };

        /* В этих переменных мы храним последнюю зарегестрированную высоту экрана */
        let lastHeight = 0, height = window.innerHeight, rect;

        /* Функция обновления размеров фона-подложки */
        const setScrollerSize = function () {
          // Задаем размеры скроллера
          // Если высота изменилась
          if (lastHeight != window.innerHeight) {
            height = window.innerHeight;
            lastHeight = height;
          }
        };

        let indentSize;
        const getContainerSize = function () {
          if (elements.wrapper) {
            const widthElem = elements.wrapper.getBoundingClientRect().width;
            leftPosition = elements.wrapper.getBoundingClientRect().left;
            elements.wrapper.style.height = widthElem * 0.5625 + 'px';
            // elements.scrollerParts[1].style.height = widthElem * 0.5625 + 'px';
            let conteinerWidth = widthElem * 0.9;
            let offset = (widthElem - conteinerWidth) / 2;
            elements.container.style.width = conteinerWidth + 'px';
            elements.container.style.height = conteinerWidth * 0.5625 + 'px';
            elements.container.style.left = offset + 'px';
            elements.bannerWrapper.style.width = widthElem + 'px';
            elements.bannerWrapper.style.height = widthElem * 0.5625 + 'px';
            elements.bannerWrapper.style.left = leftPosition + 'px';

            // const smallPartHeight = (elements.scroller.getBoundingClientRect().height - widthElem * 0.5625) / 2;
            // indentSize = smallPartHeight;
            // elements.scrollerParts[0].style.height = smallPartHeight + 'px';
            // elements.scrollerParts[2].style.height = smallPartHeight + 'px';

          }
        };

        // Проверяем обновление размеров экрана каждые 30 мсек
        setInterval(function () {
          onViewportUpdate();
          scrollerHandler();
        }, 30);

        function getHolePosition() {
          if (window.innerHeight - indentSize < elements.wrapper.getBoundingClientRect().top + elements.wrapper.getBoundingClientRect().height) {
            return 'down'
          } else if (elements.wrapper.getBoundingClientRect().top < indentSize) {
            return 'up'
          } else {
            return 'middle'
          }
        }

        function setTransform(elem, value) {
          elem.style.msTransform = value;
          elem.style.webkitTransform = value;
          elem.style.MozTransform = value;
          elem.style.OTransform = value;
          elem.style.transform = value;
        }



        let offset = 0;
        let moveBanner = 0;
        function scrollerHandler() {
          const maskRect = elements.mask.getBoundingClientRect();
          const bannerRect = elements.container.getBoundingClientRect();
          const div = (window.innerHeight + bannerRect.height) / (window.innerHeight - maskRect.height);

         if (maskRect.top + maskRect.height <= window.innerHeight && maskRect.top > 0) {
            let offsetForMask = (maskRect.top - offset);
            console.log(offsetForMask)
            let offsetForBanner = offsetForMask * div;
            moveBanner += offsetForBanner;
            elements.scrollerBanner.style.transform = 'translateY(' + (moveBanner) + 'px)';
          }

         // if (maskRect.top + maskRect.height > window.innerHeight) {
         //   elements.scrollerBanner.style.transform = 'translateY(0px)';
         // }


          offset = maskRect.top


        }

        // function scrollerHandler() {
        //   if (getHolePosition() === 'middle') {
        //     elements.scroller.style.position = 'absolute';
        //     elements.scroller.style.top = -indentSize + 'px';
        //     elements.container.style.left = '0px';
        //
        //   } else if (getHolePosition() === 'up') {
        //     elements.scroller.style.position = 'fixed';
        //     elements.scroller.style.top = '0';
        //     elements.container.style.left = leftPosition + 'px';
        //
        //   } else if (getHolePosition() === 'down') {
        //     elements.scroller.style.position = 'fixed';
        //     elements.scroller.style.bottom = '0';
        //     elements.scroller.style.top = '';
        //     elements.container.style.left = leftPosition + 'px';
        //
        //   }
        // }

        window.addEventListener('DOMContentLoaded', function() {
            getElements();
            console.log(elements.mask)
            getContainerSize();
            // window.addEventListener('scroll', scrollerHandler);
            // scrollerHandler();
            // let intervalId = setInterval(function(){
            //   elements.auto.classList.toggle('hpmdn-active')
            // }, 1000)
        });

        window.addEventListener('resize', function() {
          getContainerSize();
        })
    </script>
</body>
</html>
